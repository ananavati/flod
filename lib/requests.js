// Generated by CoffeeScript 1.3.3
(function() {
  var async, baseOptions, bench, concurrentRequests, http, latency, maxRequests, mean, median, options, printCounts, printLatency, request, requestOptions, requestPath, requestsCount, responseCount, stdDev, uri, _;

  _ = require("underscore");

  async = require("async");

  http = require("http");

  request = require("request");

  maxRequests = +process.env.MAXREQUESTS || 1000;

  concurrentRequests = +process.env.CONCREQUESTS || 50;

  requestPath = process.env.REQUESTPATH || "/";

  uri = process.env.HOST || "localhost:3000";

  http.Agent.defaultMaxSockets = concurrentRequests;

  http.globalAgent.maxSockets = concurrentRequests;

  baseOptions = {
    host: process.env.HOST,
    port: 80
  };

  requestOptions = {
    method: "GET",
    path: requestPath
  };

  requestsCount = 0;

  responseCount = 0;

  options = _.extend({}, baseOptions, requestOptions);

  latency = new Array(maxRequests);

  request = function(i, callback) {
    var r, start_time;
    i = requestsCount;
    requestsCount++;
    start_time = Date.now();
    r = http.request(options, function(res) {
      return res.on("end", function() {
        var end_time;
        end_time = Date.now();
        latency[i] = end_time - start_time;
        responseCount++;
        if (callback && typeof callback === "function") {
          return callback();
        }
      });
    });
    return r.end();
  };

  printCounts = function() {
    return console.log(requestsCount, responseCount, maxRequests);
  };

  setInterval(printCounts, 1000);

  bench = function(index, concurrents, max, callback) {
    var _i, _results;
    if (index == null) {
      index = 0;
    }
    if (concurrents == null) {
      concurrents = concurrentRequests;
    }
    if (max == null) {
      max = maxRequests;
    }
    if (callback == null) {
      callback = null;
    }
    if (index > (max - concurrents)) {
      return callback(null);
    }
    return async.forEach((function() {
      _results = [];
      for (var _i = 1; 1 <= concurrents ? _i <= concurrents : _i >= concurrents; 1 <= concurrents ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), request, function(err) {
      if (err) {
        return callback(err);
      }
      return bench(index + concurrents, concurrents, max, callback);
    });
  };

  mean = function(arr) {
    return arr.reduce(function(a, b) {
      return a + b;
    }) / arr.length;
  };

  median = function(arr) {
    var midpt, sortedArr;
    sortedArr = arr.slice(0).sort(function(a, b) {
      return a - b;
    });
    midpt = (sortedArr.length / 2) >> 0;
    if (sortedArr.length % 2 === 1) {
      return sortedArr[midpt];
    } else {
      return mean([sortedArr[midpt - 1], sortedArr[midpt]]);
    }
  };

  stdDev = function(a) {
    var arr, arrMean, differences, sdev, sumDiff, variance;
    arr = a.slice(0);
    arrMean = mean(arr);
    differences = arr.map(function(d) {
      return +(Math.pow(d - arrMean, 2)).toFixed(2);
    });
    sumDiff = differences.reduce(function(a, b) {
      return a + b;
    });
    variance = (1 / (arr.length - 1)) * sumDiff;
    sdev = Math.sqrt(variance);
    return sdev;
  };

  printLatency = function() {
    var lmean, lmedian, lstddev, max, min;
    min = Math.min.apply(this, latency);
    max = Math.max.apply(this, latency);
    lmean = mean(latency);
    lmedian = median(latency);
    lstddev = stdDev(latency);
    console.log("Latencies:");
    console.log("min =", min);
    console.log("max =", max);
    console.log("mean =", lmean);
    console.log("median =", lmedian);
    return console.log("std dev =", lstddev);
  };

  bench(0, concurrentRequests, maxRequests, function(err) {
    if (err) {
      throw err;
    }
    console.log("completed " + responseCount + " out of " + maxRequests);
    printLatency();
    return process.exit();
  });

}).call(this);
